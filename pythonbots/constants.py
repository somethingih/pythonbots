"""Global constants and helper functions for the PythonBots game.

This module defines numeric constants used throughout the game as well as
small helper functions. All identifiers are written in English for
clarity and to avoid the original Portuguese names.

There is no backwards‑compatibility layer; all code importing from
``pythonbots.globais`` in the original project should instead import
``pythonbots.constants``.
"""

# Fundamental constants.  Use ``PI`` for half‑turns and ``TAU`` (2×PI) for
# full circles.
PI = 3.1415926535897932384626433832795
TAU = 6.283185307179586476925286766559


def wall_collision_damage(velocity: float) -> float:
    """Return damage inflicted when a bot collides with a wall.

    The damage is proportional to the bot's speed. A small fraction of
    the velocity is used so that bouncing off the arena edges causes
    only minor damage.
    """
    return velocity * 0.05


def bot_collision_damage(velocity: float) -> float:
    """Return damage inflicted when two bots collide.

    Colliding with another bot inflicts more damage than hitting a wall.
    """
    return velocity * 0.1


def velocity_heat(velocity: float) -> float:
    """Return heat generated by movement.

    Faster movement generates heat which can contribute to overheating.
    """
    return velocity * 0.03


def wall_collision_heat(velocity: float) -> float:
    """Return heat generated when colliding with a wall.

    Bumping into the arena boundaries produces a burst of heat.
    """
    return velocity * 0.5


def bot_collision_heat(velocity: float) -> float:
    """Return heat generated when colliding with another bot.

    Collisions with other bots generate more heat than wall collisions.
    """
    return velocity * 0.6


def score_factor(num_bots: int, alive: int) -> float:
    """Compute the score factor for a surviving bot.

    The score factor is based on the number of participants and the
    number of bots still alive at the end of the round. A higher
    fraction of survivors yields a lower score.
    """
    return (num_bots * num_bots - 1) / float(alive)


def minabs(a: float, b: float) -> float:
    """Return the value with the smallest absolute magnitude.

    This helper is used to clamp accelerations and velocities to their
    maximum allowed values without having to repeatedly write the same
    min/abs logic.
    """
    return a if abs(a) < abs(b) else (b if a > 0 else -b)

# Global tuning constants.  These values define the physical behaviour
# of robots, projectiles and the arena.

FACTOR = 1.3125

SHOT_DAMAGE = 4.0
SHOT_COLLISION_HEAT = 1.0
TEMPERATURE_DAMAGE = 0.45

# Friction coefficients: linear and angular.
FRICTION = 0.7
ANGULAR_FRICTION = 0.1

# Projectile properties
SHOT_SPEED = 8.0

# Movement limits
MAX_ACCELERATION = 1.5 * FACTOR
MAX_TURN_RATE = 0.1
MAX_CANNON_TURN_RATE = 0.3
MIN_SCAN_ARC = 0.01

# Temperature thresholds and cooling
MAX_TEMPERATURE = 100.0
DANGEROUS_TEMPERATURE = 75.0
NORMAL_TEMPERATURE = 25.0
COOLING_RATE = 0.5
HEAT_PER_SHOT = 2.0

# Health
MAX_HEALTH = 150.0

# Geometry
RADIUS = int(10 * FACTOR)
ARENA_WIDTH = int(640 * FACTOR)
ARENA_HEIGHT = int(480 * FACTOR)
VISION_RANGE = int(340 * FACTOR)

# Time limit per round (ticks)
MAX_TIME = 10000

# Effects tuning
EXPLOSION_IMPACT = 1.5
SHOT_IMPACT_ANG = 0.01
SHOT_IMPACT_VEL = 0.1